from buildbot.buildslave import BuildSlave
from buildbot.scheduler import Scheduler, Dependent, Nightly
from buildbot.changes.pb import PBChangeSource
from buildbot.changes.filter import ChangeFilter
from buildbot.process import factory
from buildbot.process.buildstep import BuildStep
from buildbot.steps.source import Mercurial
from buildbot.steps.trigger import Trigger
from buildbot.steps.shell import WarningCountingShellCommand
from buildbot.status import html, mail
from buildbot.schedulers.trysched import Try_Userpass
from buildbot.process.properties import WithProperties
from buildbot.status.results import SUCCESS, FAILURE
import csv

# The main buildmaster configuration object (added to below).
c = BuildmasterConfig = {}

# Read a list of buildslaves and tell buildbot about them...
r = csv.reader(open('/people/amil082/docs/build-slaves.csv'))
c['slaves'] = []
slavenames = []
for row in r:
    # row[0]: name, row[1]: password, row[2]: max concurrent builds.
    slavenames.append(row[0])
    c['slaves'].append(BuildSlave(row[0], row[1], max_builds=row[2]))

# 'slavePortnum' defines the TCP port to listen on. This must match the value
# configured into the buildslaves (with their --master option)
c['slavePortnum'] = 9989

# PB is used inform the buildbot of code changes (via an external hook).
c['change_source'] = PBChangeSource()

# Create a filter that will only see changes on the default branch...
defaultFilter = ChangeFilter(branch="default")

# Make a list of builders to do on commit.
onCommitBuilders = map(lambda x: "DefaultBuild-" + x, slavenames) # + ["valgrind"]
nightlyBuilders = map(lambda x: "DefaultBuild-" + x, slavenames)

# Create scheduler which picks up commits on the default branch and triggers a
# build...
checkin = Scheduler(name="onCommitDefault", change_filter=defaultFilter,
                    builderNames=onCommitBuilders,
                    properties={"clean": True, "targets": "all test"})

# And one that runs at 11 PM every night...
nightly = Nightly(name="nightly", hour=23, builderNames=nightlyBuilders, branch='default',
                  properties={"clean": True, "targets": "all test package release"}, onlyIfChanged=True)

tryServ = Try_Userpass(name="tryServ",
                       builderNames=onCommitBuilders,
                       port=8031,
                       userpass=csv.reader(open('/people/amil082/docs/tryserv-access.csv')))

c['schedulers'] = [checkin, nightly]

# Merge build requests if they are the same.
def mergeRequests(builder, req1, req2):
    # Ignore source stamps, only look at reason...
    return req1.source.canBeMergedWith(req2.source) and (req1.reason == req2.reason)
c['mergeRequests'] = mergeRequests

# Step to ensure required properties are present or set defaults...
class CheckPropertiesSetDefault(BuildStep):
    def __init__(self, timeout=5, **kwargs):
        BuildStep.__init__(self, **kwargs)
        self.addFactoryArguments(timeout=timeout)

    def start(self):
        allSteps = { 'clean': False, 'targets': 'all test' }
        for (pn, pv) in allSteps.items():
            try:
                self.getProperty(pn)
            except KeyError:
                self.setProperty(pn, pv)
        self.finished(SUCCESS) 

# Step on how to check out the API...
class CellMLAPICheckout(Mercurial):
    def __init__(self,timeout=60*20,branchType='inrepo',repourl='/people/amil082/hgmirror/cellml-api',mode='update',**kwargs):
        Mercurial.__init__(self, repourl=repourl, mode=mode, branchType=branchType,timeout=timeout,**kwargs)
    def start(self,**kwargs):
        if self.getProperty('clean'):
	    self.args['workdir'] = 'pristine'
	    self.args['copydir'] = 'copy'
            self.args['mode'] = 'clobber'
        else:
            self.args['mode'] = 'update'
            self.args['workdir'] = 'dep'
        Mercurial.start(self, **kwargs)

# The standard factory for running a CellML build.
standardFactory = factory.BuildFactory()
# 0: Check properties & set defaults.
standardFactory.addStep(CheckPropertiesSetDefault())
# 1: Checkout.
standardFactory.addStep(CellMLAPICheckout())
# 2: Configure.
confCmd = WarningCountingShellCommand(command=
                                      ["cmake", "-DCMAKE_BUILD_TYPE:STRING=Release",
                                       "-DCHECK_BUILD:BOOL=ON",
                                       "-DENABLE_EVERYTHING:BOOL=ON", "."],
                                      timeout=60*60)
standardFactory.addStep(confCmd)
# 3: Build:
buildCmd = WarningCountingShellCommand(command=["/bin/sh", "-c", WithProperties("make %(targets)s")],
                                    timeout=60*60)
standardFactory.addStep(buildCmd)
c['builders'] = map(lambda sl: {'name': 'DefaultBuild-' + sl,
                                'slavename': sl,
                                'builddir': sl + '-api',
                                'factory': standardFactory
                                }, slavenames)

# Status targets for showing the results:
c['status'] = []
c['status'].append(html.WebStatus(http_port=8010, allowForce=True))
c['status'].append(html.WebStatus(http_port=8011, allowForce=False))

c['status'].append(mail.MailNotifier(fromaddr="automated-notifications-sender@cellml.org",
                                     extraRecipients=["automated-notifications@cellml.org"],
                                     sendToInterestedUsers=False, mode="problem",
                                     relayhost="mailhost.auckland.ac.nz"))
#
# from buildbot.status import words
# c['status'].append(words.IRC(host="irc.example.com", nick="bb",
#                              channels=["#example"]))
#
# from buildbot.status import client
# c['status'].append(client.PBListener(9988))


# Debugging options
#c['debugPassword'] = "debugpassword"

# if you set 'manhole', you can ssh into the buildmaster and get an
# interactive python shell, which may be useful for debugging buildbot
# internals. It is probably only useful for buildbot developers. You can also
# use an authorized_keys file, or plain telnet.
#from buildbot import manhole
#c['manhole'] = manhole.PasswordManhole("tcp:9999:interface=127.0.0.1",
#                                       "admin", "password")

# The 'projectName' string will be used to describe the project that this
# buildbot is working on. For example, it is used as the title of the
# waterfall HTML page. The 'projectURL' string will be used to provide a link
# from buildbot HTML pages to your project's home page.
c['projectName'] = "The CellML Project"
c['projectURL'] = "http://www.cellml.org/"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.Waterfall page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.
c['buildbotURL'] = "http://autotest.bioeng.auckland.ac.nz/cellml-build/"
